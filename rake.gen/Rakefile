# Rakefile for automatically generate Makefiles.
#
# Author: Santa Zhang (santa1987@gmail.com)

require 'find'

# execute a command
def my_exec cmds
  cmds.each_line do |cmd|
    cmd = cmd.strip
    puts "[cmd] #{cmd}"
    system cmd
  end
end

if File.exists? "rake.gen.conf"
  load "rake.gen.conf"
else
  puts "Warning: 'rake.gen.conf' not found! Automatically determine config info!"
  folders = []
  Dir.entries(".").each do |e|
    next if e.start_with? "."
    if File::directory? e
      folders.push e
    end
  end
  BUILD_MODULES = folders
  DEFAULT_BUILD_MODULES = BUILD_MODULES
  BUILD_MODES = {
    "" => {
      "CC" => "gcc",
      "CXX" => "g++",
      "CFLAGS" => "-O3",
      "CXXFLAGS" => "-O3",
      "LDFLAGS" => ""
    }
  }
end

# the final buildable targets, used when generating 'all-xxx' targets.
# its a map (build_mode -> list of targets)
$g_targets = {}

# acceptable source code extension
$source_ext = [".c", ".cc", ".cpp", ".cxx" ]

# randomly generate a token with alphabets, like 'acd', 'zfc', etc.
def random_token length = 5
  token = ""
  alphabets = "abcdefghijklmnopqrstuvwxyz"
  1.upto(length) do |i|
    idx = rand(alphabets.length)
    token += alphabets[idx..idx]
  end
  return token
end

# Join string list. Skip empty strings.
def my_join join_str, str_list
  stripped_str_list = str_list.select {|str| str.length != 0}
  stripped_str_list.join join_str
end

# check if a source file has 'main()' function
def has_main_entry? file
  File.open(file).read =~ /^int main\(/
end

# remove the extension from file path
def drop_ext f
  ext = File.extname f
  f[0..-ext.length - 1]
end

# get the source file corresponding to a file.
# if .h was given, corresponding .c .cc .cpp .cxx file will be returned
# if .c .cc .cpp .cxx, it self will be returned
def source_file_of f
  case File.extname(f)
  when ".h"
    $source_ext.each do |ext|
      src_fn = drop_ext(f) + ext
      return src_fn if File.exists? src_fn
    end
    return nil
  else
    return f
  end
end

# finds all depended obj file, including inherit dependency
def depended_obj file, build_mode
  visited = []
  not_visited = depended_header file

  loop do
    break if not_visited.length == 0
    header = not_visited[0]
    src_file = source_file_of header
    if src_file != nil
      depended_header(src_file).each do |h|
        (not_visited << h) if not (not_visited.include? h or visited.include? h)
      end
      visited << header
    end
    not_visited.delete header
  end
  obj_list = visited.map do |header|
    (my_join "-", ["obj", build_mode]) + "/#{drop_ext(header)}.o"
  end
  obj_list = obj_list.sort
  obj_list = obj_list.uniq
  return obj_list
end

# finds all directly depended header files, without inherit dependency
def depended_header file
  list = []
  src_file = source_file_of file
  if src_file != nil
    File.open(source_file_of file) do |src_f|
      src_f.each_line do |line|
        line = line.strip
        if line =~ /#include \"/
          header = line[10..-2]
          list.concat(all_src_files.select {|f| f.end_with? header})
        end
      end
    end
  end
  if File.exist? drop_ext(file) + ".h"
    File.open(drop_ext(file) + ".h") do |src_f|
      src_f.each_line do |line|
        line = line.strip
        if line =~ /#include \"/
          header = line[10..-2]
          list.concat(all_src_files.select {|f| f.end_with? header})
        end
      end
    end
  end
  list = list.uniq
  list = list.sort
  return list
end

# get all build targets in a module, with a given build mode. it also sets up the final build targets
def all_targets_in_module mod, build_mode
  puts "Analyzing targets in #{my_join "-", [build_mode, mod]}"
  depend = {mod => []}
  action = {mod => []}

  all_obj_list = []
  all_bin_list = [] # all the executable file list

  Find.find(mod) do |path|
    if defined? CONFIGURE_H
      next if File.basename(path) == File.basename(CONFIGURE_H)
    end
    next if FileTest.directory? path
    cc_or_cxx = nil
    cc_or_cxx_flags = nil
    ext_name = File.extname path
    if ext_name == ".c"
      # for C
      cc_or_cxx = "CC"
      cc_or_cxx_flags = "CFLAGS"
    elsif $source_ext.include? ext_name
      # for C++
      cc_or_cxx = "CXX"
      cc_or_cxx_flags = "CXXFLAGS"
    end
    if cc_or_cxx != nil
      obj_name = (my_join "-", ["obj", build_mode]) + "/#{drop_ext(path) + ".o"}"
      all_obj_list << obj_name
      if has_main_entry? path
        bin_name = (my_join "-", ["bin", build_mode]) + "/#{drop_ext(File.basename path)}"
        all_bin_list << bin_name
        depend[mod] << bin_name

        depend[bin_name] = [] if depend[bin_name] == nil
        depend[bin_name] << obj_name
        depend[bin_name].concat(depended_obj path, build_mode)

        action[bin_name] = [] if action[bin_name] == nil
        action[bin_name] << "@$(#{my_join "_", [cc_or_cxx, build_mode]}) $(#{my_join "_", [cc_or_cxx_flags, build_mode]}) $(#{my_join "_", ["LDFLAGS", build_mode]}) #{obj_name} #{(depended_obj path, build_mode).join " "} -o #{bin_name} ; echo \"  [link] #{bin_name}\""

        # a global build target
        all_xxx = my_join "_", ["all", build_mode]
        $g_targets[all_xxx] = [] if $g_targets[all_xxx] == nil
        $g_targets[all_xxx] << bin_name
      end

      depend[mod] << obj_name

      depend[obj_name] = [] if depend[obj_name] == nil
      depend[obj_name] << path
      depend[obj_name].concat(depended_header path)

      action[obj_name] = [] if action[obj_name] == nil
      action[obj_name] << "@$(#{my_join "_", [cc_or_cxx, build_mode]}) $(#{my_join "_", [cc_or_cxx_flags, build_mode]}) -c #{path} -o #{obj_name} ; echo \"  [$(#{my_join "_", [cc_or_cxx, build_mode]})] #{path}\""
    end
  end

  if defined? LIB_MODULES and LIB_MODULES.include? mod
    # make .a file
    lib_name = (my_join "-", ["bin", build_mode]) + "/lib#{mod}.a"
    depend[mod] << lib_name

    depend[lib_name] = [] if depend[lib_name] == nil
    depend[lib_name] << all_obj_list

    action[lib_name] = [] if action[lib_name] == nil
    action[lib_name] << "@ar cq #{lib_name} $^ ; echo \"  [ar] #{lib_name}\""
    action[lib_name] << "@ranlib #{lib_name} ; echo \"  [ranlib] #{lib_name}\""
    action[lib_name] << ""

    all_xxx = my_join "_", ["all", build_mode]
    $g_targets[all_xxx] = [] if $g_targets[all_xxx] == nil
    $g_targets[all_xxx] << lib_name
  end

  if defined? TEST_MODULES and TEST_MODULES.include? mod
    # add a run-#{mod}-verbose target
    run_mod = my_join "-", ["run-#{mod}-verbose", build_mode]
    depend[run_mod] = [] if depend[run_mod] == nil
    depend[run_mod] << (my_join "-", [mod, build_mode])

    action[run_mod] = [] if action[run_mod] == nil
    action[run_mod] << "@clear"

    echo_info = "Running test module \\'#{mod}\\'"
    action[run_mod] << "@echo #{echo_info}"
    action[run_mod] << "@echo #{"=" * (echo_info.length - 2)}"

    test_case_counter = 1
    all_bin_list = all_bin_list.sort
    all_bin_list.each do |e|
      echo_info =  "#{test_case_counter} of #{all_bin_list.length}: Running test case \\'#{File.basename e}\\'"
      action[run_mod] << "@echo #{echo_info}"
      action[run_mod] << "@echo #{"-" * (echo_info.length - 2)}"
      action[run_mod] << "@#{e}"
      action[run_mod] << "@echo #{"-" * (echo_info.length - 2)}"
      action[run_mod] << "@echo"
      test_case_counter += 1
    end

    all_xxx = my_join "_", ["all", build_mode]
    $g_targets[all_xxx] = [] if $g_targets[all_xxx] == nil
    $g_targets[all_xxx] += all_bin_list

    # add a silent run-#{mode} target
    run_mod = my_join "-", ["run-#{mod}", build_mode]
    depend[run_mod] = [] if depend[run_mod] == nil
    depend[run_mod] << (my_join "-", [mod, build_mode])

    action[run_mod] = [] if action[run_mod] == nil

    echo_info = "Running test module \\'#{mod}\\'"
    action[run_mod] << "@echo #{echo_info}"
    action[run_mod] << "@echo #{"=" * (echo_info.length - 2)}"

    all_bin_list = all_bin_list.sort
    all_bin_list.each do |e|
      e_main_fn = File.basename e
      action[run_mod] << "@((#{e} > /dev/null 2>&1) && echo [pass] #{e_main_fn}) || echo [fail] #{e_main_fn}"
    end
    action[run_mod] << "@echo"

    all_xxx = my_join "_", ["all", build_mode]
    $g_targets[all_xxx] = [] if $g_targets[all_xxx] == nil
    $g_targets[all_xxx] += all_bin_list
  end

  content = ""
  depend.keys.sort.each do |target|
    depend[target] = depend[target].sort
    if BUILD_MODULES.include? target
      content += <<CONTENT
#{my_join "-", [target, build_mode]}: #{my_join "-", ["bin", build_mode]} #{my_join "-", ["obj", build_mode]} #{depend[target].join " "}
#{action[target].collect {|act| "\t#{act}\n"}}
CONTENT
    else
      content += <<CONTENT
#{target}: #{depend[target].join " "}
#{action[target].collect {|act| "\t#{act}\n"}}
CONTENT
    end
  end

  return content
end

# generate all targets with a certain build mode
def gen_make_targets build_mode

  # clear g_targets, because this function will be run many times
  $g_targets = {}

  content = ""
  BUILD_MODULES.sort.each do |mod|
    content += all_targets_in_module mod, build_mode
    content += "\n"
  end

  # generate build target for 'all_xxx' targets
  content += "#{my_join "-", ["all", build_mode]}: "
  content += "#{my_join "-", ["bin", build_mode]} "
  content += "#{my_join "-", ["obj", build_mode]} "
  $g_targets.keys.sort.each do |target|
    content += $g_targets[target].join(" ")
  end
  content += "\n\n"
  return content
end

# return a list of all source files (.h, .c .cc .cxx .cpp)
# like find . -iname *.h && find . -iname *.c
$g_all_src_files = nil
def all_src_files
  return $g_all_src_files if $g_all_src_files != nil
  $g_all_src_files = []
  BUILD_MODULES.sort.each do |mod|
    Find.find(mod) do |path|
      if FileTest.directory? path
        # do nothing
      elsif File.extname(path) == ".h" or $source_ext.include? File.extname(path)
        unless defined? CONFIGURE_H and File.basename(CONFIGURE_H) == File.basename(path)
          $g_all_src_files << path
        end
      end
    end
  end
  return $g_all_src_files
end

#return a list of all directories in source folders
def mk_obj_dirs_list
  list = []
  BUILD_MODULES.sort.each do |mod|
    Find.find(mod) do |path|
      if FileTest.directory? path
        list << path
      end
    end
  end
  list = list.sort
  min_list = []
  if list.length < 2
    min_list = list
  else
    (0..(list.length - 2)).each do |idx|
      a = list[idx]
      b = list[idx + 1]
      if (b.start_with? a) == false
        min_list << a
      end
      if idx == list.length - 2
        min_list << b
      end
    end
  end
  return min_list
end

# assert that there is no duplicate file name in any folder
# note that folder1/a.c and folder2/a.c are duplicated!
def assert_no_duplicate_fname
  inverse_map = {}
  all_src_files.each do |path|
    base_name = File.basename path
    if inverse_map.has_key? base_name
      raise "Duplicate file name: '#{path}' & '#{inverse_map[base_name]}'"
    end
    inverse_map[base_name] = path
  end
end

# ensure that every source code file either has an associated .h file, or they have main() entry
def assert_src_header_pair
  flist = all_src_files
  flist.each do |path|
    if $source_ext.include? File.extname(path)
      header_path = drop_ext(path) + ".h"
      if has_main_entry? path
        # has main() entry, so there should not be a .h file
        raise "'#{path}' already have main() entry, so '#{header_path}' is not needed!" if flist.include? header_path
      else
        # does not have main() entry, so it must have a .h file
        raise "'#{path}' found, but '#{header_path}' does not exist!" unless flist.include? header_path
      end
    end
  end
end

# check if there is bad coding style
def warn_bad_style
  flist = all_src_files

  flist.each do |path|
    if defined? NO_STYLE_CHECK
      should_skip = false
      NO_STYLE_CHECK.each do |mod|
        if path.start_with? mod
          should_skip = true
          break
        end
      end
      next if should_skip
    end

    if defined? CONFIGURE_H
      next if File.basename(path) == File.basename(CONFIGURE_H)
    end

    # check if used tabs in spacing
    File.open(path) do |f|
      row = 1
      f.each_line do |line|
        if line =~ /^[ ]*\t/
          puts "style warning: #{path}, #{row}: please don't use tab for spacing"
        end
        row += 1
      end
    end

    # check if has #ifndef guard
    if path.end_with? ".h"
      File.open(path) do |f|
        has_guard = false
        guard_name = nil
        f.each_line do |line|
          if line =~ /^#pragma.*once$/
            has_guard = true
            break
          end
          if guard_name == nil
            if line =~ /^\#ifndef.*_H_$/
              guard_name = line.split[-1]
            end
          else
            # last line is #ifndef, so this line must be #define
            if line =~ /^\#define/ and line.include? guard_name
              has_guard = true
              break
            else
              guard_name = nil
            end
          end

        end

        if has_guard == false
          puts "style warning: #{path}, no #ifndef guard found!"
        end
      end
    end

    # check if #endif are followed by comments
    File.open(path) do |f|
      row = 1
      f.each_line do |line|
        if line =~ /^\#endif/
          unless line.include? '//' or line.include? '/*'
            puts "style warning: #{path}:#{row}, #endif should be followed by comments!"
          end
        end
        row += 1
      end
    end

    # check if .h files have got @author
    if path.end_with? ".h"
      has_author_tag = false
      File.open(path) do |f|
        f.each_line do |line|
          if line =~ /@author/
            has_author_tag = true
          end
        end
      end
      if has_author_tag == false
        puts "style warning: #{path}, does not have @author tag!"
      end
    end

    # check if there is multiple return in one function, when there is memory allocation
    File.open(path) do |f|
      inside_fun = nil
      return_rows = []
      row = 1
      has_mem_alloc = false
      f.each_line do |line|
        if line =~ /^[a-z].*\{[ \t]*$/
          inside_fun = line.strip[0..-2].strip
          return_rows = []
          has_mem_alloc = false
        elsif line =~ /^\}.*/
          inside_fun = nil
          if return_rows.size > 1 and has_mem_alloc == true
            puts "style warning: #{path}:[#{return_rows.join ", "}], multiple return statement in one function, when there is memory allocation!"
          end
          return_rows = []
          has_mem_alloc = false
        elsif inside_fun != nil
          if line =~ /^[ \t]*return .*;.*$/
            return_rows << row
          elsif line =~ /[a-z]*_new\(/ or line =~ /malloc[a-z_]*\(/
            has_mem_alloc = true
          end
        end
        row += 1
      end
    end

    # check if has trailing white space
    File.read(path).each_line do |line|
      line = line.chomp
      if line.end_with? ' ' or line.end_with? '\t'
        puts "style warning: #{path} has trailing whitespaces"
        break
      end
    end

  end
end

desc "Do style checking"
task :check do
  puts "Checking project..."
  puts "List of files to be checked:"
  all_src_files.each do |f|
    puts "  #{f}"
  end
  puts "--"
  warn_bad_style
  assert_no_duplicate_fname
  puts "No duplicate file name"
  assert_src_header_pair
  puts "All source code files either has got a .h file, or they have main() entry"
  puts "Finished checking"
end

desc "Generate Makefile"
task :gen => :check do
  if defined? GEN_MINGW32_MAKEFILE and GEN_MINGW32_MAKEFILE == true and defined? GEN_CONFIGURE_SCRIPT and GEN_CONFIGURE_SCRIPT == true
    raise "GEN_MINGW32_MAKEFILE and GEN_CONFIGURE_SCRIPT cannot both be true"
  end
  if defined? GEN_CONFIGURE_SCRIPT and GEN_CONFIGURE_SCRIPT == true
    puts "Generating Makefile.in"
  else
    puts "Generating Makefile"
  end

  # Default build mode
  unless defined? BUILD_MODES
    puts 'warning: BUILD_MODES not defined in rake.gen.conf, using default settings'
    BUILD_MODES = {
      "" => {
        "CC" => "gcc",
        "CXX" => "g++",
        "CFLAGS" => "-Wall",
        "CXXFLAGS" => "-Wall",
        "LDFLAGS" => ""
      }
    }
  end

  mf_targets = ["clean", "distclean", "help"]
  mf_targets += BUILD_MODULES
  if defined? TEST_MODULES
    mf_targets += TEST_MODULES.collect {|mod| "run-#{mod}-verbose"}
    mf_targets += TEST_MODULES.collect {|mod| "run-#{mod}"}
  end
  mf_default_targets = []

  mf_header = <<MF_EOF
# WARNING! This file is automatically generated by "rake gen".
# WARNING! Any modification to it would be lost after another "rake gen" operation!

# Automatically generated at #{Time.now}
MF_EOF

  mf_content_linux = <<MF_EOF
MKDIR_P=mkdir -p
RMRF=rm -rf
DEL_RECURSIVE=find . -iname
DEL_RECURSIVE_OPTIONS=-delete
MF_EOF

  mf_content_mingw32 = <<MF_EOF
MKDIR_P=md
RMRF=rd /S /Q
DEL_RECURSIVE=for /r %f in
DEL_RECURSIVE_OPTIONS=do del "%f"
MF_EOF

  mf_content = <<MF_EOF
#{
BUILD_MODES.collect do |mode, settings|
  <<MODE_CONSTS
#{my_join("_", ["CC", mode])}=#{settings["CC"]}
#{my_join("_", ["CXX", mode])}=#{settings["CXX"]}
#{my_join("_", ["CFLAGS", mode])}=#{BUILD_MODULES.collect {|mod| "-I#{mod} "}} #{settings["CFLAGS"]}
#{my_join("_", ["CXXFLAGS", mode])}=#{BUILD_MODULES.collect {|mod| "-I#{mod} "}} #{settings["CXXFLAGS"]}
#{my_join("_", ["LDFLAGS", mode])}=#{settings["LDFLAGS"]}
MODE_CONSTS
end
}

#{
default_build_mode = BUILD_MODES.first[0]
if defined? DEFAULT_BUILD_MODE
  default_build_mode = DEFAULT_BUILD_MODE
end
if default_build_mode != ""
  mf_default_targets << default_build_mode
else
  mf_default_targets << (my_join '-', ['bin', default_build_mode])
  mf_default_targets << (my_join '-', ['obj', default_build_mode])
  DEFAULT_BUILD_MODULES.each do |mod|
    mf_default_targets << (my_join '-', [mod, default_build_mode])
  end
end
"default: #{mf_default_targets.join ' '}"
}

#{
BUILD_MODES.collect do |build_mode, settings|
  if build_mode != ""
    mf_targets << build_mode
    mf_targets << "all-#{build_mode}"
    "#{build_mode}: #{my_join '-', ['bin', build_mode]} #{my_join '-', ['obj', build_mode]} #{DEFAULT_BUILD_MODULES.collect {|mod| (my_join '-', [mod, build_mode]) + ' '}}\n\n"
  else
    mf_targets << "all"
    "" # don't write any thing to Makefile
  end
end
}

#{
BUILD_MODES.collect do |mode, settings|
  bin_target = my_join "-", ["bin", mode]
  <<BIN_TARGET
#{bin_target}:
	@$(MKDIR_P) #{bin_target} ; echo \"  [mkdir] #{bin_target}\"

BIN_TARGET
end
}

#{
BUILD_MODES.collect do |mode, settings|
  obj_target = my_join "-", ["obj", mode]
  <<OBJ_TARGET
#{obj_target}:
#{mk_obj_dirs_list.collect {|dir| "\t@$(MKDIR_P) #{obj_target}/#{dir} ; echo \"  [mkdir] #{obj_target}/#{dir}\"\n"}}

OBJ_TARGET
end
}

#{
if File.exists? "Doxyfile"
  # only enable "make api" when there is already an Doxyfile
  mf_targets << "api"
"api: #{all_src_files.collect {|f| f + " "}}
	doxygen
"
end
}

clean:
	$(RMRF) #{BUILD_MODES.collect {|mode, settings| (my_join "-", ["bin", mode]) + " "}}
	$(RMRF) #{BUILD_MODES.collect {|mode, settings| (my_join "-", ["obj", mode]) + " "}}
	$(RMRF) api
	$(DEL_RECURSIVE) \*.log $(DEL_RECURSIVE_OPTIONS)
	$(DEL_RECURSIVE) \*~ $(DEL_RECURSIVE_OPTIONS)

distclean:
	$(RMRF) Makefile
	$(RMRF) Makefile.in

#{
BUILD_MODES.collect do |mode, settings|
  gen_make_targets mode
end
}

#{
# default test targets
default_build_mode = BUILD_MODES.first[0]
if defined? DEFAULT_BUILD_MODE
  default_build_mode = DEFAULT_BUILD_MODE
end
if defined? TEST_MODULES and default_build_mode != ""
  TEST_MODULES.collect do |mod|
    <<RUN_MODULE_CMD
run-#{mod}-verbose: #{my_join "-", ["run-#{mod}-verbose", default_build_mode]}
run-#{mod}: #{my_join "-", ["run-#{mod}", default_build_mode]}
RUN_MODULE_CMD
  end
end
}

#{
default_build_mode = BUILD_MODES.first[0]
if defined? DEFAULT_BUILD_MODE
  default_build_mode = DEFAULT_BUILD_MODE
end
if default_build_mode != ""
  BUILD_MODULES.collect do |mod|
    "#{mod}: #{my_join "-", [mod, default_build_mode]}\n\n"
  end
end
}

#{
if !(defined? GEN_CONFIGURE_SCRIPT) or GEN_CONFIGURE_SCRIPT == false
  "include Makefile.in" if File.exists? "#{File.dirname __FILE__}/Makefile.in"
end
}

MF_EOF

  if defined? INSTALL_DEPENDS or defined? INSTALL_ACTIONS
    mf_targets << "install"
  end
  if defined? UNINSTALL_ACTIONS
    mf_targets << "uninstall"
  end
  mf_targets.sort!
  mf_targets.uniq!

  mf_tail_linux = <<MF_EOF
help:
#{
mf_targets.collect do |target|
  if mf_default_targets.include? target
    "\t@echo \"* #{target}\"\n"
  else
    "\t@echo \"  #{target}\"\n"
  end
end
}
MF_EOF

  mf_tail_mingw32 = <<MF_EOF
help:
#{
mf_targets.collect do |target|
  if mf_default_targets.include? target
    "\t@echo * #{target}\n"
  else
    "\t@echo   #{target}\n"
  end
end
}
MF_EOF

  if defined? GEN_CONFIGURE_SCRIPT and GEN_CONFIGURE_SCRIPT == true
    File.open("Makefile.in", "w") do |mf|
      mf.write(mf_header + mf_content_linux + mf_content + mf_tail_linux)
    end
    puts "Generating configure script"
    gen_configure_script
  else
    File.open("Makefile", "w") do |mf|
      mf.write(mf_header + mf_content_linux + mf_content + mf_tail_linux)
    end
  end

  if defined? GEN_MINGW32_MAKEFILE and GEN_MINGW32_MAKEFILE == true
    File.open("Makefile.mingw32", "w") do |mf|
      mf.write(mf_header + mf_content_mingw32 + mf_content + mf_tail_mingw32)
    end
  end
end

def gen_configure_script
  cfg = <<CFG_FILE
#!/bin/sh

# WARNING! This file is automatically generated by 'rake gen' operation!
# WARNING! Any modification made to it will be lost after another 'rake gen' operation!

# Automatically generated on #{Time.now}

print_help() {
  echo "This configure script is automatically generated by 'rake gen'"
  echo "Get help: './configure -h' or './configure --help'"
  echo ""
#{
if defined? CONFIGURE_HEADERS
  <<EOF
echo "Header files that would be checked:"
#{
  header_echo = CONFIGURE_HEADERS.sort.collect do |header_fn|
    "echo \"  #{header_fn}  (use 'HAVE_#{header_fn.gsub(/\/|\./, "_").upcase}' macro)\""
  end
  header_echo.join "\n"
}
echo ""
EOF
end
}
#{
if defined? CONFIGURE_LIBS
  <<EOF
echo "Library dependency:"
#{
  lib_echo = CONFIGURE_LIBS.keys.sort.collect do |lib_fn|
    "echo \"  #{lib_fn}\""
  end
  lib_echo.join "\n"
}
echo ""
EOF
end
}
#{
if defined? CONFIGURE_SWITCHES
  <<EOF
echo "Default compile switches:"
#{
  swt_echo = CONFIGURE_SWITCHES.keys.sort.collect do |swt|
    if CONFIGURE_SWITCHES[swt] == "true"
      "echo \"  --enable-#{swt}  (macro: ENABLE_#{swt.gsub("-", "_").upcase}=1)\""
    else
      "echo \"  --disable-#{swt}  (macro: ENABLE_#{swt.gsub("-", "_").upcase}=0)\""
    end
  end
  swt_echo.join "\n"
}
echo ""
EOF
end
}
#{
if defined? CONFIGURE_OPTIONS
  <<EOF
echo "Default configure options:"
#{
  opt_echo = CONFIGURE_OPTIONS.keys.sort.collect do |opt|
    if CONFIGURE_OPTIONS[opt] == nil
      "echo \"  #{opt}  (empty)\""
    else
      "echo \"  #{opt}=#{CONFIGURE_OPTIONS[opt]}\""
    end
  end
  opt_echo.join "\n"
}
echo ""
EOF
end
}
  exit 0
}

# check if need to show help info
for i in $*
do
  case $i in
  -h)
    print_help
    ;;
  --help)
    print_help
    ;;
  *)
    # unknown options
    ;;
  esac
done


# set default values
#{
if defined? CONFIGURE_OPTIONS
  all_params = CONFIGURE_OPTIONS.collect do |param, value|
    if value != nil
      "#{param.gsub("-", "_")}=#{value}"
    end
  end
  all_params.delete_if {|item| item == nil}
  all_params.join "\n"
end
}

#{
if defined? CONFIGURE_H and defined? CONFIGURE_SWITCHES
  all_params = CONFIGURE_SWITCHES.collect do |param, value|
    "ENABLE_#{param.gsub("-", "_").upcase}=#{value}"
  end
  all_params.join "\n"
end
}

# start param parsing
for i in $*
do
  case $i in
#{
if defined? CONFIGURE_OPTIONS
  CONFIGURE_OPTIONS.keys.collect do |param|
    "  --#{param}=*)\n" +
    "    #{param.gsub("-", "_")}=`echo $i | sed 's/[-a-zA-z0-9]*=//'`\n" +
    "    ;;\n"
  end
end
}
#{
if defined? CONFIGURE_H and defined? CONFIGURE_SWITCHES
  CONFIGURE_SWITCHES.collect do |param, value|
    param_var_name = "ENABLE_#{param.gsub("-", "_").upcase}"
    "  --enable-#{param}*)\n" +
    "    #{param_var_name}=\"true\"\n" +
    "    ;;\n" +
    "  --disable-#{param}*)\n" +
    "    #{param_var_name}=\"false\"\n" +
    "    ;;\n"
  end
end
}
  *)
    # unknown options
    ;;
  esac
done


#{
if defined? CONFIGURE_BINARIES
  "echo \"Checking binaries\""
end
}
#{
if defined? CONFIGURE_BINARIES
  all_binaries = CONFIGURE_BINARIES.collect do |bin_file|
    "which #{bin_file} 2>&1 >> /dev/null\n" +
    "if [ \"$?\" -ne \"0\" ] ; then\n" +
    "  echo \"Binary not found: #{bin_file}\"\n" +
    "  exit 1\n" +
    "fi"
  end
  all_binaries.join "\n"
end
}

random_token=`cat /dev/urandom | od -N2 -An -i | awk '{print $1}'`
test_filename="configure.test.`date '+%y%m%d%H%M%S'`-${random_token}"
test_file_content="int main(){return 0;}"

#{
if defined? CONFIGURE_LIBS
  "echo \"Checking libraries\""
end
}
#{
if defined? CONFIGURE_LIBS
  all_libs = CONFIGURE_LIBS.collect do |lib_fn, err_msg|
    "echo ${test_file_content} > /tmp/${test_filename}.c\n" +
    "gcc /tmp/${test_filename}.c -l#{lib_fn[3..-1]} -o /tmp/${test_filename}.out\n" +
    "if [ \"$?\" -ne \"0\" ] ; then\n" +
    "  echo \"#{lib_fn}: no\"\n" +
    "  echo \"#{err_msg}\"\n" +
    "  rm -rf /tmp/${test_filename}.c /tmp/${test_filename}.out\n" + 
    "  exit 1\n" +
    "else\n" +
    "  echo \"#{lib_fn}: yes\"\n" +
    "  rm -rf /tmp/${test_filename}.c /tmp/${test_filename}.out\n" + 
    "fi"
  end
  all_libs.join "\n"
end
}
#{
if defined? CONFIGURE_H
  "echo \"Generating #{CONFIGURE_H}\"\n" +
  "rm -rf #{CONFIGURE_H}\n" +
  "echo \"// Automatically generated by './configure' on `date`\" >> #{CONFIGURE_H}\n" +
  "echo \"#ifndef CONFIGURE_H\" >> #{CONFIGURE_H}\n" +
  "echo \"#define CONFIGURE_H\" >> #{CONFIGURE_H}"
end
}
#{
if defined? CONFIGURE_H and defined? CONFIGURE_DEFINES
  CONFIGURE_DEFINES.collect do |item, value|
    if value.class == String
      # wrap up string value
      value = "\\\"#{value}\\\""
    end
    "  echo \"\" >> #{CONFIGURE_H}\n" +
    "  echo \"#define #{item} #{value}\" >> #{CONFIGURE_H}\n" +
    "  echo \"\" >> #{CONFIGURE_H}\n"
  end
end
}
#{
if defined? CONFIGURE_H and defined? CONFIGURE_SWITCHES
  all_params = CONFIGURE_SWITCHES.keys.collect do |param|
    param_var_name = "ENABLE_#{param.gsub("-", "_").upcase}"
    "echo \"\" >> #{CONFIGURE_H}\n" +
    "if [ ${#{param_var_name}} == \"true\" ] ; then\n" +
    "  echo \"#define #{param_var_name} 1\" >> #{CONFIGURE_H}\n" +
    "else\n" +
    "  echo \"#define #{param_var_name} 0\" >> #{CONFIGURE_H}\n" +
    "fi\n" +
    "echo \"\" >> #{CONFIGURE_H}\n"
  end
  all_params.join "\n"
end
}
#{
if defined? CONFIGURE_H and defined? CONFIGURE_HEADERS
  all_headers = CONFIGURE_HEADERS.collect do |header_fn|
    "echo \"#include \\\"#{header_fn}\\\"\" > /tmp/${test_filename}.c\n" +
    "echo ${test_file_content} >> /tmp/${test_filename}.c\n" +
    "gcc /tmp/${test_filename}.c -o /tmp/${test_filename}.out 2>&1 | grep \"#{header_fn}.*No such file\" >> /dev/null\n" +
    "if [ \"$?\" -ne \"0\" ] ; then\n" +
    "  echo \"#{header_fn}: yes\"\n" +
    "  echo \"\" >> #{CONFIGURE_H}\n" +
    "  echo \"#define HAVE_#{header_fn.upcase.gsub(/\/|\./, "_")}\" >> #{CONFIGURE_H}\n" +
    "  echo \"\" >> #{CONFIGURE_H}\n" +
    "else\n" +
    "  echo \"#{header_fn}: no\"\n" +
    "fi\n" +
    "rm -rf /tmp/${test_filename}.c /tmp/${test_filename}.out\n" 
  end
  all_headers.join "\n"
end
}
#{
if defined? CONFIGURE_H
  "echo \"#endif // CONFIGURE_H\" >> #{CONFIGURE_H}"
end
}


echo "Generating Makefile"
rm -f Makefile
touch Makefile
echo "# WARNING! This file is automatically generated by './configure'." >> Makefile
echo "# WARNING! Any modifications to it will be lost after another './configure' operation!" >> Makefile
echo "" >> Makefile
echo "# Automatically generated at `date`" >> Makefile
echo "" >> Makefile
echo "include Makefile.in" >> Makefile
echo "" >> Makefile
echo "install: #{INSTALL_DEPENDS.join " " if defined? INSTALL_DEPENDS}" >> Makefile 
#{
if defined? INSTALL_ACTIONS
  all_actions = INSTALL_ACTIONS.collect do |action|
    "echo \"\t#{action}\" >> Makefile"
  end
  all_actions.join "\n"
end
}

#{
if defined? UNINSTALL_ACTIONS
  all_actions = UNINSTALL_ACTIONS.collect do |action|
    "echo \"\t#{action}\" >> Makefile"
  end
  "echo \"\" >> Makefile\necho \"uninstall:\" >> Makefile\n" + (all_actions.join "\n")
end
}

CFG_FILE
  File.open("configure", "w") do |cf|
    cf.write(cfg)
  end
  `chmod a+x configure`
end

desc "Show all notes like TODO, ENHANCE, etc"
task :notes do
  ["TODO", "NOTE", "ENHANCE", "XXX", "FIXME"].each do |note|
    if defined? SHOW_NOTES
      SHOW_NOTES.each do |entry|
        system "grep #{note} #{entry} -r -n --color"
      end
    else
      system "grep #{note} * -r -n --color"
    end
    puts
  end
end

task :default do
  puts "Run 'rake -T' to get list of functions"
  puts "Run 'rake gen' to generate Makefile"
end

def nth_line text, nth
  counter = 0
  text.each_line do |line|
    line = line.chomp
    counter += 1
    return line if counter == nth
  end
  return nil
end

desc "Make .tar.gz pack for source distribution"
task :tar do
  token = random_token

  project_name = File.basename(File.expand_path(File.dirname(__FILE__)))

  source_root = File.dirname __FILE__
  
  # check if clean (git status, line 2 not start with '#')
  if nth_line(`git status`, 2).include? '#'
    puts "*** not a clean workspace, please git commit first!"
    exit
  end
  
  # ok, workspace is clean, now determine tar_fn post fix
  current_commit_hash = nth_line(`git show`, 1).split[1]
  puts current_commit_hash
  
  tar_postfix = "snapshot-#{current_commit_hash[0..6]}"
  
  `git tag`.each_line do |line|
    tag = line.strip
    tag_commit_hash = nth_line(`git show #{tag}`, 1).split[1]
    if tag_commit_hash == current_commit_hash
      tar_postfix = tag
      break
    end
  end
  
  if tar_postfix != ""
    tar_main_fn = "#{project_name}-#{tar_postfix}"
  else
    tar_main_fn = project_name
  end
  tar_fn = "#{source_root}/#{tar_main_fn}.tar.gz"

  # git clone to a temp dir in '/tmp'
  clone_folder_parent = "/tmp/#{project_name}-make-tar.#{token}"
  clone_folder = "#{clone_folder_parent}/#{tar_main_fn}"

  my_exec <<CMD
git clone #{source_root} #{clone_folder}
rm -Rf #{clone_folder}/.git
#{
  if defined? IGNORE_IN_TAR
    (IGNORE_IN_TAR.collect {|e| "rm -Rf #{clone_folder}/#{e}"}).join "\n"
  end
}
rm -f #{tar_fn}
cd #{clone_folder}/.. && tar pczf #{tar_fn} #{tar_main_fn}
rm -Rf #{clone_folder_parent}
CMD
  puts "Created #{tar_main_fn}.tar.gz in source root folder!"
end

def trim_right line
  line = line.chomp
  if (line.end_with? ' ') or (line.end_with? '\t')
    line.chop!
    return (trim_right line)
  end
  line
end

desc "Fix bad styles"
task :fix do
  puts "fixing trailing whitespaces"

  flist = all_src_files
  flist.each do |path|
    if defined? NO_STYLE_CHECK
      should_skip = false
      NO_STYLE_CHECK.each do |mod|
        if path.start_with? mod
          should_skip = true
          break
        end
      end
      next if should_skip
    end

    all_lines = File.read path
    File.open(path, "w") do |f_out|
      note_printed = false
      all_lines.each_line do |line|
        trimmed_line = trim_right(line)
        unless note_printed
          if "#{trimmed_line}\n" != line
            puts "removed trailing whitespace: #{path}"
            note_printed = true
          end
        end
        f_out.write "#{trimmed_line}\n"
      end
    end
  end

end

